{"data":{"ghostPost":{"id":"Ghost__Post__5ce3c3de9f845f2425e992e2","title":"JavaScript Promise and Async / Await Part 1: Introduction to Promise","slug":"introduction-to-promise","featured":false,"feature_image":"http://waiyanyoon.com/content/images/2019/05/javascript_promises.svg","excerpt":"So you've clicked the title to read this post. I know you're a JavaScript\ndeveloper by then. You've probably seen \"promise\" and \"async / await\" flying\neverywhere in Medium and blog posts written by developers with at least a slight\nof knowledge about it. There's a big chance that you've been using Promise all\nthis while with the mind of \"it just works\" without knowing the reason behind\nthe .then  chain.\n\nIn this post, we'll discover a little bit of history behind Promise, by\nimplementing a coupl","custom_excerpt":null,"created_at_pretty":"21 May, 2019","published_at_pretty":"22 May, 2019","updated_at_pretty":"22 May, 2019","created_at":"2019-05-21T17:24:46.000+08:00","published_at":"2019-05-22T18:01:00.000+08:00","updated_at":"2019-05-22T20:39:30.000+08:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Yoon Wai Yan","slug":"yoonwaiyan","bio":null,"profile_image":"http://waiyanyoon.com/content/images/2018/04/yoonwaiyan-1.jpeg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Yoon Wai Yan","slug":"yoonwaiyan","bio":null,"profile_image":"http://waiyanyoon.com/content/images/2018/04/yoonwaiyan-1.jpeg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"JavaScript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"JavaScript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"So you've clicked the title to read this post. I know you're a JavaScript\ndeveloper by then. You've probably seen \"promise\" and \"async / await\" flying\neverywhere in Medium and blog posts written by developers with at least a slight\nof knowledge about it. There's a big chance that you've been using Promise all\nthis while with the mind of \"it just works\" without knowing the reason behind\nthe .then  chain.\n\nIn this post, we'll discover a little bit of history behind Promise, by\nimplementing a couple of API calls to Github to retrieve a user's profile and\nrepositories.\n\nIf you're a seasoned developer for years, you've probably attempted this at some\npoint in your career:\n\nfunction getUser(username) {\n  request(\"https://api.github.com/users/\" + username, function(\n    userError,\n    userReponse,\n    user\n  ) {\n    console.log(\"user\", user);\n\n    request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n      reposError,\n      reposResponse,\n      repos\n    ) {\n      console.log(\"repos\", repos);\n\n      return { user: user, repos: repos };\n    });\n  });\n\n  return { user: null, repos: [] };\n};\n\nGetting value from a function that calls API asynchronously is not an easy task.\nThis is the value returned by calling the function above:\n\nvar userInfo = getInfo(\"gaearon\");\nconsole.log(userInfo); // returns { user: null, repos: [] }\n\nDue to the asynchronous nature of JavaScript language, the API calls are not\nhandled by getUser  function. At this point, maybe you'll try to a callback to\nassign a variable within the callback function:\n\nfunction getUserWithCallback(username, callback) {\n  request(\"https://api.github.com/users/\" + username, function(\n    userError,\n    userReponse,\n    user\n  ) {\n    console.log(\"user\", user);\n\n    request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n      reposError,\n      reposResponse,\n      repos\n    ) {\n      console.log(\"repos\", repos);\n      \n      var result = { user: user, repos: repos };\n      callback(result);\n      \n      return result;\n    });\n  });\n\n  return { user: null, repos: [] };\n};\n\nlet callbackUserInfo;\ncallbackGetUser(\"yoonwaiyan\", userInfo => {\n  callbackUserInfo = userInfo;\n});\nconsole.log(\"callbackUserInfo\", callbackUserInfo); // undefined\n\nNow, the callbackGetUser  process is way out of space and there's no way to\ncatch it back and console.log  merely tells you it went missing. You might think\nthat callback works, but declaring a function with a callback argument won't\nmake it an asynchronous. See here for more info\n[https://stackoverflow.com/questions/19083357/are-all-javascript-callbacks-asynchronous-if-not-how-do-i-know-which-are]\n\nIf you're in a hurry to get this call working, you'll probably remove the\nfunction altogether and resort in the main call instead:\n\nlet userInfo, userRepos;\nrequest(\"https://api.github.com/users/\" + username, function(\n  userError,\n  userReponse,\n  user\n) {\n  userInfo = user;\n  console.log(\"userInfo\", userInfo);\n\n  request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n    reposError,\n    reposResponse,\n    repos\n  ) {\n    userRepos = repos;\n    console.log(\"main repos\", userRepos.length);\n\n    // future calculations or DOM manipulation\n  });\n});\n\nWelcome to callback hell [http://callbackhell.com/].\n\nIf you've ever code something similar to this, you feel the pain of not finding\na way to reduce the nested blocks. If you're like me, feeling icky to find a\nsolution to end this monstrous bite to stop me from the Path towards Clean Code,\nyou've probably used Promise to chain the callbacks by using .then.\n\nUse Promise Chain for Consecutive Asynchronous Calls\nSince few years ago, Promise has been the standard used in APIs provided by\nmajor library developers to an extend that it's even harder to find libraries\nwithout returning a Promise by default. Requesting user data from Github is much\neasier with the use of octokit rest client [https://github.com/octokit/rest.js/]\n.\n\noctokit.users\n  .getByUsername({\n    username\n  })\n  .then(({ data }) => {\n    console.log(\"data\", data);\n    setUser(data);\n  })\n  .then(() => {\n    return octokit.repos.listForUser({\n      username\n    });\n  })\n  .then(({ data }) => {\n    setRepos(data);\n    setLoading(false);\n  })\n  .catch(error => {\n    console.log(\"error\", error);\n  });\n\nUse Promise chain to avoid nested blocksSimilar result can be obtained by using axios [https://github.com/axios/axios] \ntoo, if using API client is not favorable due to certain reasons:\n\nlet user, repos;\naxios\n  .get(url)\n  .then(data => {\n    user = data.data;\n  })\n  .then(() => {\n    return axios.get(`${url}/repos`);\n  })\n  .then(data => {\n    repos = data.data;\n  });\n\nAh that's pretty neat!Create a Promise Function\nFrom the snipper above, axios.get  is a function that returns a Promise object.\nA Promise object consists of a property namedthen, with a callback constructor\nthat returns resolve  and reject  . \n\nlet foo = new Promise(function(resolve, reject) {\n  resolve('Success!');\n});\n\nAs a rule of thumb, every Promise defined should have both resolve  and reject \nbeing called. Typically resolve  works like a function, while reject   tells\ncaller that something is wrong within the function.\n\nLet's try re-implement the getUser  function. This function does the same thing\nas getUser  function we've seen earlier, with Promise implemented:\n\nconst getUser = username => {\n  return new Promise(async (resolve, reject) => {\n    const url = `https://api.github.com/users/${username}`;\n    let user, repos;\n    axios\n      .get(url)\n      .then(data => {\n        user = data.data;\n      })\n      .then(() => {\n        return axios.get(`${url}/repos`);\n      })\n      .then(data => {\n        repos = data.data;\n        resolve({ user, repos });\n      })\n      .catch(error => {\n        reject(error);\n      });\n  });\n};\n\nNow we can call getUser  function like how we use then  previously:\n\ngetUser(username).then(data => {\n  console.log(\"getUser\", data);\n});\n\n// output: getUser Object {user: Object, repos: Array[30]}\n\nPromise.all\nNow we're able to call getUser  function to get both user profile and user\nrepos. Experienced developers might noticed that Promise chain runs linearly.\nThe API call to obtain user repositories only triggered after the first API call\nto get user profile, but the API to get user's repositories doesn't rely on\nwhat's being returned from user profile! We can now improve the performance by\ncalling both APIs asynchronously. \n\nThat means we're going to separate both calls to different Promise calls.\n\nconst loadUser = octokit.users\n  .getByUsername({\n    username\n  })\n  .then(() => {\n    setUser(loadUser);\n  });\n\nconst loadRepos = octokit.repos\n  .listForUser({\n    username\n  })\n  .then(() => {\n    setRepos(loadRepos);\n  });\n\nIt looked syntactically correct, but now both calls are asynchronous without\nbeing controlled, which would easily obstruct the program flow in overall.\nYou'll need a manager to consolidate both calls to return data first before\nproceed. Let us hire Promise.all  to do that.\n\nconst dataPromises = [\n  octokit.users.getByUsername({\n    username\n  }),\n  octokit.repos.listForUser({\n    username\n  })\n];\n\nPromise.all(dataPromises).then(allPromises => {\n  const [userCall, repoCall] = allPromises;\n  setUser(userCall.data);\n  setRepos(repoCall.data);\n  setLoading(false);\n});\n\nPromise.all  will make sure every async call is finished before resolving all\npromises into one single array consists of the resolved data of each async call\nfollowing the order in dataPromises  array.\n\nConclusion\nThere's a deep knowledge of asynchronous programming in JavaScript which is\navailable to read online for free [https://eloquentjavascript.net/11_async.html]\n, and this blog post merely scratching the surface by introducing the practical\napplication of Promise in our projects using Node.js or any modern JavaScript\ntools including frontend frameworks and libraries. Based on my personal\nexperience, it is important to make sure every Promise is being handled, as a\nprogram might remain running indefinitely if the async calls are not being\nhandled properly, and this is especially hard to debug if you have many async\ncalls scattered across files within a project.\n\nBy going through the improvements from a callback hell to using Promise.all  to\nrun two API calls asynchronously, hope this makes things clearer for you to\nunderstand how to utilize JavaScript Promise.\n\nExternal Read and Resources\n 1. https://medium.freecodecamp.org/how-to-make-a-promise-out-of-a-callback-function-in-javascript-d8ec35d1f981\n 2. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\n 3. https://eloquentjavascript.net/11_async.html","html":"<p>So you've clicked the title to read this post. I know you're a JavaScript developer by then. You've probably seen \"promise\" and \"async / await\" flying everywhere in Medium and blog posts written by developers with at least a slight of knowledge about it. There's a big chance that you've been using Promise all this while with the mind of \"it just works\" without knowing the reason behind the <code>.then</code> chain.</p><p>In this post, we'll discover a little bit of history behind Promise, by implementing a couple of API calls to Github to retrieve a user's profile and repositories.</p><p>If you're a seasoned developer for years, you've probably attempted this at some point in your career:</p><!--kg-card-begin: code--><pre><code class=\"language-javascript\">function getUser(username) {\n  request(\"https://api.github.com/users/\" + username, function(\n    userError,\n    userReponse,\n    user\n  ) {\n    console.log(\"user\", user);\n\n    request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n      reposError,\n      reposResponse,\n      repos\n    ) {\n      console.log(\"repos\", repos);\n\n      return { user: user, repos: repos };\n    });\n  });\n\n  return { user: null, repos: [] };\n};</code></pre><!--kg-card-end: code--><p>Getting value from a function that calls API asynchronously is not an easy task. This is the value returned by calling the function above:</p><!--kg-card-begin: code--><pre><code>var userInfo = getInfo(\"gaearon\");\nconsole.log(userInfo); // returns { user: null, repos: [] }</code></pre><!--kg-card-end: code--><p>Due to the asynchronous nature of JavaScript language, the API calls are not handled by <code>getUser</code> function. At this point, maybe you'll try to a callback to assign a variable within the callback function:</p><!--kg-card-begin: code--><pre><code>function getUserWithCallback(username, callback) {\n  request(\"https://api.github.com/users/\" + username, function(\n    userError,\n    userReponse,\n    user\n  ) {\n    console.log(\"user\", user);\n\n    request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n      reposError,\n      reposResponse,\n      repos\n    ) {\n      console.log(\"repos\", repos);\n      \n      var result = { user: user, repos: repos };\n      callback(result);\n      \n      return result;\n    });\n  });\n\n  return { user: null, repos: [] };\n};</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>let callbackUserInfo;\ncallbackGetUser(\"yoonwaiyan\", userInfo =&gt; {\n  callbackUserInfo = userInfo;\n});\nconsole.log(\"callbackUserInfo\", callbackUserInfo); // undefined</code></pre><!--kg-card-end: code--><p>Now, the <code>callbackGetUser</code> process is way out of space and there's no way to catch it back and <code>console.log</code> merely tells you it went missing. You might think that callback works, but <strong>declaring a function with a callback argument won't make it an asynchronous</strong>. <a href=\"https://stackoverflow.com/questions/19083357/are-all-javascript-callbacks-asynchronous-if-not-how-do-i-know-which-are\">See here for more info</a></p><p>If you're in a hurry to get this call working, you'll probably remove the function altogether and resort in the main call instead:</p><!--kg-card-begin: code--><pre><code>let userInfo, userRepos;\nrequest(\"https://api.github.com/users/\" + username, function(\n  userError,\n  userReponse,\n  user\n) {\n  userInfo = user;\n  console.log(\"userInfo\", userInfo);\n\n  request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n    reposError,\n    reposResponse,\n    repos\n  ) {\n    userRepos = repos;\n    console.log(\"main repos\", userRepos.length);\n\n    // future calculations or DOM manipulation\n  });\n});</code></pre><!--kg-card-end: code--><p>Welcome to <a href=\"http://callbackhell.com/\">callback hell</a>.</p><p>If you've ever code something similar to this, you feel the pain of not finding a way to reduce the nested blocks. If you're like me, feeling icky to find a solution to end this monstrous bite to stop me from the Path towards Clean Code, you've probably used Promise to chain the callbacks by using <code>.then</code>.</p><h2 id=\"use-promise-chain-for-consecutive-asynchronous-calls\">Use Promise Chain for Consecutive Asynchronous Calls</h2><p>Since few years ago, Promise has been the standard used in APIs provided by major library developers to an extend that it's even harder to find libraries without returning a Promise by default. Requesting user data from Github is much easier with the use of <a href=\"https://github.com/octokit/rest.js/\">octokit rest client</a>.</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-es6\">octokit.users\n  .getByUsername({\n    username\n  })\n  .then(({ data }) =&gt; {\n    console.log(\"data\", data);\n    setUser(data);\n  })\n  .then(() =&gt; {\n    return octokit.repos.listForUser({\n      username\n    });\n  })\n  .then(({ data }) =&gt; {\n    setRepos(data);\n    setLoading(false);\n  })\n  .catch(error =&gt; {\n    console.log(\"error\", error);\n  });</code></pre><figcaption>Use Promise chain to avoid nested blocks</figcaption></figure><!--kg-card-end: code--><p>Similar result can be obtained by using <a href=\"https://github.com/axios/axios\">axios</a> too, if using API client is not favorable due to certain reasons:</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-es6\">let user, repos;\naxios\n  .get(url)\n  .then(data =&gt; {\n    user = data.data;\n  })\n  .then(() =&gt; {\n    return axios.get(`${url}/repos`);\n  })\n  .then(data =&gt; {\n    repos = data.data;\n  });</code></pre><figcaption>Ah that's pretty neat!</figcaption></figure><!--kg-card-end: code--><h2 id=\"create-a-promise-function\">Create a Promise Function</h2><p>From the snipper above, <code>axios.get</code> is a function that returns a Promise object. A Promise object consists of a property named  <code>then</code>, with a callback constructor that returns <code>resolve</code> and <code>reject</code> . </p><!--kg-card-begin: code--><pre><code>let foo = new Promise(function(resolve, reject) {\n  resolve('Success!');\n});</code></pre><!--kg-card-end: code--><p>As a rule of thumb, every Promise defined should have both <code>resolve</code> and <code>reject</code> being called. Typically <code>resolve</code> works like a function, while <code>reject</code>  tells caller that something is wrong within the function.</p><p>Let's try re-implement the <code>getUser</code> function. This function does the same thing as <code>getUser</code> function we've seen earlier, with Promise implemented:</p><!--kg-card-begin: code--><pre><code class=\"language-es6\">const getUser = username =&gt; {\n  return new Promise(async (resolve, reject) =&gt; {\n    const url = `https://api.github.com/users/${username}`;\n    let user, repos;\n    axios\n      .get(url)\n      .then(data =&gt; {\n        user = data.data;\n      })\n      .then(() =&gt; {\n        return axios.get(`${url}/repos`);\n      })\n      .then(data =&gt; {\n        repos = data.data;\n        resolve({ user, repos });\n      })\n      .catch(error =&gt; {\n        reject(error);\n      });\n  });\n};</code></pre><!--kg-card-end: code--><p>Now we can call <code>getUser</code> function like how we use <code>then</code> previously:</p><!--kg-card-begin: code--><pre><code>getUser(username).then(data =&gt; {\n  console.log(\"getUser\", data);\n});\n\n// output: getUser Object {user: Object, repos: Array[30]}</code></pre><!--kg-card-end: code--><h2 id=\"promise-all\">Promise.all</h2><p>Now we're able to call <code>getUser</code> function to get both user profile and user repos. Experienced developers might noticed that Promise chain runs <em>linearly</em>. The API call to obtain user repositories only triggered after the first API call to get user profile, but the API to get user's repositories doesn't rely on what's being returned from user profile! We can now improve the performance by calling both APIs asynchronously. </p><p>That means we're going to separate both calls to different Promise calls.</p><!--kg-card-begin: code--><pre><code>const loadUser = octokit.users\n  .getByUsername({\n    username\n  })\n  .then(() =&gt; {\n    setUser(loadUser);\n  });\n\nconst loadRepos = octokit.repos\n  .listForUser({\n    username\n  })\n  .then(() =&gt; {\n    setRepos(loadRepos);\n  });</code></pre><!--kg-card-end: code--><p>It looked syntactically correct, but now both calls are asynchronous without being controlled, which would easily obstruct the program flow in overall. You'll need a manager to consolidate both calls to return data first before proceed. Let us hire <code>Promise.all</code> to do that.</p><!--kg-card-begin: code--><pre><code class=\"language-es6\">const dataPromises = [\n  octokit.users.getByUsername({\n    username\n  }),\n  octokit.repos.listForUser({\n    username\n  })\n];\n\nPromise.all(dataPromises).then(allPromises =&gt; {\n  const [userCall, repoCall] = allPromises;\n  setUser(userCall.data);\n  setRepos(repoCall.data);\n  setLoading(false);\n});</code></pre><!--kg-card-end: code--><p><code>Promise.all</code> will make sure every async call is finished before resolving all promises into one single array consists of the resolved data of each async call following the order in <code>dataPromises</code> array.</p><h2 id=\"conclusion\">Conclusion</h2><p>There's a deep knowledge of asynchronous programming in JavaScript which is available to <a href=\"https://eloquentjavascript.net/11_async.html\">read online for free</a>, and this blog post merely scratching the surface by introducing the practical application of Promise in our projects using Node.js or any modern JavaScript tools including frontend frameworks and libraries. Based on my personal experience, it is important to make sure every Promise is being handled, as a program might remain running indefinitely if the async calls are not being handled properly, and this is especially hard to debug if you have many async calls scattered across files within a project.</p><p>By going through the improvements from a callback hell to using <code>Promise.all</code> to run two API calls asynchronously, hope this makes things clearer for you to understand how to utilize JavaScript Promise.</p><h2 id=\"external-read-and-resources\">External Read and Resources</h2><ol><li><a href=\"https://medium.freecodecamp.org/how-to-make-a-promise-out-of-a-callback-function-in-javascript-d8ec35d1f981\">https://medium.freecodecamp.org/how-to-make-a-promise-out-of-a-callback-function-in-javascript-d8ec35d1f981</a></li><li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then</a></li><li><a href=\"https://eloquentjavascript.net/11_async.html\">https://eloquentjavascript.net/11_async.html</a></li></ol>","url":"http://waiyanyoon.com/introduction-to-promise/","uuid":"c2c233a6-21f1-4b9e-b05d-18a110bba835","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5ce3c3de9f845f2425e992e2"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"introduction-to-promise"}}