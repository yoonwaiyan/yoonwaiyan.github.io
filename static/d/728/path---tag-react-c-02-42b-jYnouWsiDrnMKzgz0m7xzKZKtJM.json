{"data":{"ghostTag":{"slug":"react","name":"React","visibility":"public","feature_image":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5ce3c3de9f845f2425e992e2","title":"JavaScript Promise and Async / Await Part 1: Introduction to Promise","slug":"introduction-to-promise","featured":false,"feature_image":"http://waiyanyoon.com/content/images/2019/05/javascript_promises.svg","excerpt":"So you've clicked the title to read this post. I know you're a JavaScript\ndeveloper by then. You've probably seen \"promise\" and \"async / await\" flying\neverywhere in Medium and blog posts written by developers with at least a slight\nof knowledge about it. There's a big chance that you've been using Promise all\nthis while with the mind of \"it just works\" without knowing the reason behind\nthe .then  chain.\n\nIn this post, we'll discover a little bit of history behind Promise, by\nimplementing a coupl","custom_excerpt":null,"created_at_pretty":"21 May, 2019","published_at_pretty":"22 May, 2019","updated_at_pretty":"22 May, 2019","created_at":"2019-05-21T17:24:46.000+08:00","published_at":"2019-05-22T18:01:00.000+08:00","updated_at":"2019-05-22T20:39:30.000+08:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Yoon Wai Yan","slug":"yoonwaiyan","bio":null,"profile_image":"http://waiyanyoon.com/content/images/2018/04/yoonwaiyan-1.jpeg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Yoon Wai Yan","slug":"yoonwaiyan","bio":null,"profile_image":"http://waiyanyoon.com/content/images/2018/04/yoonwaiyan-1.jpeg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"JavaScript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"JavaScript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"So you've clicked the title to read this post. I know you're a JavaScript\ndeveloper by then. You've probably seen \"promise\" and \"async / await\" flying\neverywhere in Medium and blog posts written by developers with at least a slight\nof knowledge about it. There's a big chance that you've been using Promise all\nthis while with the mind of \"it just works\" without knowing the reason behind\nthe .then  chain.\n\nIn this post, we'll discover a little bit of history behind Promise, by\nimplementing a couple of API calls to Github to retrieve a user's profile and\nrepositories.\n\nIf you're a seasoned developer for years, you've probably attempted this at some\npoint in your career:\n\nfunction getUser(username) {\n  request(\"https://api.github.com/users/\" + username, function(\n    userError,\n    userReponse,\n    user\n  ) {\n    console.log(\"user\", user);\n\n    request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n      reposError,\n      reposResponse,\n      repos\n    ) {\n      console.log(\"repos\", repos);\n\n      return { user: user, repos: repos };\n    });\n  });\n\n  return { user: null, repos: [] };\n};\n\nGetting value from a function that calls API asynchronously is not an easy task.\nThis is the value returned by calling the function above:\n\nvar userInfo = getInfo(\"gaearon\");\nconsole.log(userInfo); // returns { user: null, repos: [] }\n\nDue to the asynchronous nature of JavaScript language, the API calls are not\nhandled by getUser  function. At this point, maybe you'll try to a callback to\nassign a variable within the callback function:\n\nfunction getUserWithCallback(username, callback) {\n  request(\"https://api.github.com/users/\" + username, function(\n    userError,\n    userReponse,\n    user\n  ) {\n    console.log(\"user\", user);\n\n    request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n      reposError,\n      reposResponse,\n      repos\n    ) {\n      console.log(\"repos\", repos);\n      \n      var result = { user: user, repos: repos };\n      callback(result);\n      \n      return result;\n    });\n  });\n\n  return { user: null, repos: [] };\n};\n\nlet callbackUserInfo;\ncallbackGetUser(\"yoonwaiyan\", userInfo => {\n  callbackUserInfo = userInfo;\n});\nconsole.log(\"callbackUserInfo\", callbackUserInfo); // undefined\n\nNow, the callbackGetUser  process is way out of space and there's no way to\ncatch it back and console.log  merely tells you it went missing. You might think\nthat callback works, but declaring a function with a callback argument won't\nmake it an asynchronous. See here for more info\n[https://stackoverflow.com/questions/19083357/are-all-javascript-callbacks-asynchronous-if-not-how-do-i-know-which-are]\n\nIf you're in a hurry to get this call working, you'll probably remove the\nfunction altogether and resort in the main call instead:\n\nlet userInfo, userRepos;\nrequest(\"https://api.github.com/users/\" + username, function(\n  userError,\n  userReponse,\n  user\n) {\n  userInfo = user;\n  console.log(\"userInfo\", userInfo);\n\n  request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n    reposError,\n    reposResponse,\n    repos\n  ) {\n    userRepos = repos;\n    console.log(\"main repos\", userRepos.length);\n\n    // future calculations or DOM manipulation\n  });\n});\n\nWelcome to callback hell [http://callbackhell.com/].\n\nIf you've ever code something similar to this, you feel the pain of not finding\na way to reduce the nested blocks. If you're like me, feeling icky to find a\nsolution to end this monstrous bite to stop me from the Path towards Clean Code,\nyou've probably used Promise to chain the callbacks by using .then.\n\nUse Promise Chain for Consecutive Asynchronous Calls\nSince few years ago, Promise has been the standard used in APIs provided by\nmajor library developers to an extend that it's even harder to find libraries\nwithout returning a Promise by default. Requesting user data from Github is much\neasier with the use of octokit rest client [https://github.com/octokit/rest.js/]\n.\n\noctokit.users\n  .getByUsername({\n    username\n  })\n  .then(({ data }) => {\n    console.log(\"data\", data);\n    setUser(data);\n  })\n  .then(() => {\n    return octokit.repos.listForUser({\n      username\n    });\n  })\n  .then(({ data }) => {\n    setRepos(data);\n    setLoading(false);\n  })\n  .catch(error => {\n    console.log(\"error\", error);\n  });\n\nUse Promise chain to avoid nested blocksSimilar result can be obtained by using axios [https://github.com/axios/axios] \ntoo, if using API client is not favorable due to certain reasons:\n\nlet user, repos;\naxios\n  .get(url)\n  .then(data => {\n    user = data.data;\n  })\n  .then(() => {\n    return axios.get(`${url}/repos`);\n  })\n  .then(data => {\n    repos = data.data;\n  });\n\nAh that's pretty neat!Create a Promise Function\nFrom the snipper above, axios.get  is a function that returns a Promise object.\nA Promise object consists of a property namedthen, with a callback constructor\nthat returns resolve  and reject  . \n\nlet foo = new Promise(function(resolve, reject) {\n  resolve('Success!');\n});\n\nAs a rule of thumb, every Promise defined should have both resolve  and reject \nbeing called. Typically resolve  works like a function, while reject  Â tells\ncaller that something is wrong within the function.\n\nLet's try re-implement the getUser  function. This function does the same thing\nas getUser  function we've seen earlier, with Promise implemented:\n\nconst getUser = username => {\n  return new Promise(async (resolve, reject) => {\n    const url = `https://api.github.com/users/${username}`;\n    let user, repos;\n    axios\n      .get(url)\n      .then(data => {\n        user = data.data;\n      })\n      .then(() => {\n        return axios.get(`${url}/repos`);\n      })\n      .then(data => {\n        repos = data.data;\n        resolve({ user, repos });\n      })\n      .catch(error => {\n        reject(error);\n      });\n  });\n};\n\nNow we can call getUser  function like how we use then  previously:\n\ngetUser(username).then(data => {\n  console.log(\"getUser\", data);\n});\n\n// output: getUser Object {user: Object, repos: Array[30]}\n\nPromise.all\nNow we're able to call getUser  function to get both user profile and user\nrepos. Experienced developers might noticed that Promise chain runs linearly.\nThe API call to obtain user repositories only triggered after the first API call\nto get user profile, but the API to get user's repositories doesn't rely on\nwhat's being returned from user profile! We can now improve the performance by\ncalling both APIs asynchronously. \n\nThat means we're going to separate both calls to different Promise calls.\n\nconst loadUser = octokit.users\n  .getByUsername({\n    username\n  })\n  .then(() => {\n    setUser(loadUser);\n  });\n\nconst loadRepos = octokit.repos\n  .listForUser({\n    username\n  })\n  .then(() => {\n    setRepos(loadRepos);\n  });\n\nIt looked syntactically correct, but now both calls are asynchronous without\nbeing controlled, which would easily obstruct the program flow in overall.\nYou'll need a manager to consolidate both calls to return data first before\nproceed. Let us hire Promise.all  to do that.\n\nconst dataPromises = [\n  octokit.users.getByUsername({\n    username\n  }),\n  octokit.repos.listForUser({\n    username\n  })\n];\n\nPromise.all(dataPromises).then(allPromises => {\n  const [userCall, repoCall] = allPromises;\n  setUser(userCall.data);\n  setRepos(repoCall.data);\n  setLoading(false);\n});\n\nPromise.all  will make sure every async call is finished before resolving all\npromises into one single array consists of the resolved data of each async call\nfollowing the order in dataPromises  array.\n\nConclusion\nThere's a deep knowledge of asynchronous programming in JavaScript which is\navailable to read online for free [https://eloquentjavascript.net/11_async.html]\n, and this blog post merely scratching the surface by introducing the practical\napplication of Promise in our projects using Node.js or any modern JavaScript\ntools including frontend frameworks and libraries. Based on my personal\nexperience, it is important to make sure every Promise is being handled, as a\nprogram might remain running indefinitely if the async calls are not being\nhandled properly, and this is especially hard to debug if you have many async\ncalls scattered across files within a project.\n\nBy going through the improvements from a callback hell to using Promise.all  to\nrun two API calls asynchronously, hope this makes things clearer for you to\nunderstand how to utilize JavaScript Promise.\n\nExternal Read and Resources\n 1. https://medium.freecodecamp.org/how-to-make-a-promise-out-of-a-callback-function-in-javascript-d8ec35d1f981\n 2. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\n 3. https://eloquentjavascript.net/11_async.html","html":"<p>So you've clicked the title to read this post. I know you're a JavaScript developer by then. You've probably seen \"promise\" and \"async / await\" flying everywhere in Medium and blog posts written by developers with at least a slight of knowledge about it. There's a big chance that you've been using Promise all this while with the mind of \"it just works\" without knowing the reason behind the <code>.then</code> chain.</p><p>In this post, we'll discover a little bit of history behind Promise, by implementing a couple of API calls to Github to retrieve a user's profile and repositories.</p><p>If you're a seasoned developer for years, you've probably attempted this at some point in your career:</p><!--kg-card-begin: code--><pre><code class=\"language-javascript\">function getUser(username) {\n  request(\"https://api.github.com/users/\" + username, function(\n    userError,\n    userReponse,\n    user\n  ) {\n    console.log(\"user\", user);\n\n    request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n      reposError,\n      reposResponse,\n      repos\n    ) {\n      console.log(\"repos\", repos);\n\n      return { user: user, repos: repos };\n    });\n  });\n\n  return { user: null, repos: [] };\n};</code></pre><!--kg-card-end: code--><p>Getting value from a function that calls API asynchronously is not an easy task. This is the value returned by calling the function above:</p><!--kg-card-begin: code--><pre><code>var userInfo = getInfo(\"gaearon\");\nconsole.log(userInfo); // returns { user: null, repos: [] }</code></pre><!--kg-card-end: code--><p>Due to the asynchronous nature of JavaScript language, the API calls are not handled by <code>getUser</code> function. At this point, maybe you'll try to a callback to assign a variable within the callback function:</p><!--kg-card-begin: code--><pre><code>function getUserWithCallback(username, callback) {\n  request(\"https://api.github.com/users/\" + username, function(\n    userError,\n    userReponse,\n    user\n  ) {\n    console.log(\"user\", user);\n\n    request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n      reposError,\n      reposResponse,\n      repos\n    ) {\n      console.log(\"repos\", repos);\n      \n      var result = { user: user, repos: repos };\n      callback(result);\n      \n      return result;\n    });\n  });\n\n  return { user: null, repos: [] };\n};</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>let callbackUserInfo;\ncallbackGetUser(\"yoonwaiyan\", userInfo =&gt; {\n  callbackUserInfo = userInfo;\n});\nconsole.log(\"callbackUserInfo\", callbackUserInfo); // undefined</code></pre><!--kg-card-end: code--><p>Now, the <code>callbackGetUser</code> process is way out of space and there's no way to catch it back and <code>console.log</code> merely tells you it went missing. You might think that callback works, but <strong>declaring a function with a callback argument won't make it an asynchronous</strong>. <a href=\"https://stackoverflow.com/questions/19083357/are-all-javascript-callbacks-asynchronous-if-not-how-do-i-know-which-are\">See here for more info</a></p><p>If you're in a hurry to get this call working, you'll probably remove the function altogether and resort in the main call instead:</p><!--kg-card-begin: code--><pre><code>let userInfo, userRepos;\nrequest(\"https://api.github.com/users/\" + username, function(\n  userError,\n  userReponse,\n  user\n) {\n  userInfo = user;\n  console.log(\"userInfo\", userInfo);\n\n  request(\"https://api.github.com/users/\" + username + \"/repos\", function(\n    reposError,\n    reposResponse,\n    repos\n  ) {\n    userRepos = repos;\n    console.log(\"main repos\", userRepos.length);\n\n    // future calculations or DOM manipulation\n  });\n});</code></pre><!--kg-card-end: code--><p>Welcome to <a href=\"http://callbackhell.com/\">callback hell</a>.</p><p>If you've ever code something similar to this, you feel the pain of not finding a way to reduce the nested blocks. If you're like me, feeling icky to find a solution to end this monstrous bite to stop me from the Path towards Clean Code, you've probably used Promise to chain the callbacks by using <code>.then</code>.</p><h2 id=\"use-promise-chain-for-consecutive-asynchronous-calls\">Use Promise Chain for Consecutive Asynchronous Calls</h2><p>Since few years ago, Promise has been the standard used in APIs provided by major library developers to an extend that it's even harder to find libraries without returning a Promise by default. Requesting user data from Github is much easier with the use of <a href=\"https://github.com/octokit/rest.js/\">octokit rest client</a>.</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-es6\">octokit.users\n  .getByUsername({\n    username\n  })\n  .then(({ data }) =&gt; {\n    console.log(\"data\", data);\n    setUser(data);\n  })\n  .then(() =&gt; {\n    return octokit.repos.listForUser({\n      username\n    });\n  })\n  .then(({ data }) =&gt; {\n    setRepos(data);\n    setLoading(false);\n  })\n  .catch(error =&gt; {\n    console.log(\"error\", error);\n  });</code></pre><figcaption>Use Promise chain to avoid nested blocks</figcaption></figure><!--kg-card-end: code--><p>Similar result can be obtained by using <a href=\"https://github.com/axios/axios\">axios</a> too, if using API client is not favorable due to certain reasons:</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-es6\">let user, repos;\naxios\n  .get(url)\n  .then(data =&gt; {\n    user = data.data;\n  })\n  .then(() =&gt; {\n    return axios.get(`${url}/repos`);\n  })\n  .then(data =&gt; {\n    repos = data.data;\n  });</code></pre><figcaption>Ah that's pretty neat!</figcaption></figure><!--kg-card-end: code--><h2 id=\"create-a-promise-function\">Create a Promise Function</h2><p>From the snipper above, <code>axios.get</code> is a function that returns a Promise object. A Promise object consists of a property named Â <code>then</code>, with a callback constructor that returns <code>resolve</code> and <code>reject</code> . </p><!--kg-card-begin: code--><pre><code>let foo = new Promise(function(resolve, reject) {\n  resolve('Success!');\n});</code></pre><!--kg-card-end: code--><p>As a rule of thumb, every Promise defined should have both <code>resolve</code> and <code>reject</code> being called. Typically <code>resolve</code> works like a function, while <code>reject</code> Â tells caller that something is wrong within the function.</p><p>Let's try re-implement the <code>getUser</code> function. This function does the same thing as <code>getUser</code> function we've seen earlier, with Promise implemented:</p><!--kg-card-begin: code--><pre><code class=\"language-es6\">const getUser = username =&gt; {\n  return new Promise(async (resolve, reject) =&gt; {\n    const url = `https://api.github.com/users/${username}`;\n    let user, repos;\n    axios\n      .get(url)\n      .then(data =&gt; {\n        user = data.data;\n      })\n      .then(() =&gt; {\n        return axios.get(`${url}/repos`);\n      })\n      .then(data =&gt; {\n        repos = data.data;\n        resolve({ user, repos });\n      })\n      .catch(error =&gt; {\n        reject(error);\n      });\n  });\n};</code></pre><!--kg-card-end: code--><p>Now we can call <code>getUser</code> function like how we use <code>then</code> previously:</p><!--kg-card-begin: code--><pre><code>getUser(username).then(data =&gt; {\n  console.log(\"getUser\", data);\n});\n\n// output: getUser Object {user: Object, repos: Array[30]}</code></pre><!--kg-card-end: code--><h2 id=\"promise-all\">Promise.all</h2><p>Now we're able to call <code>getUser</code> function to get both user profile and user repos. Experienced developers might noticed that Promise chain runs <em>linearly</em>. The API call to obtain user repositories only triggered after the first API call to get user profile, but the API to get user's repositories doesn't rely on what's being returned from user profile! We can now improve the performance by calling both APIs asynchronously. </p><p>That means we're going to separate both calls to different Promise calls.</p><!--kg-card-begin: code--><pre><code>const loadUser = octokit.users\n  .getByUsername({\n    username\n  })\n  .then(() =&gt; {\n    setUser(loadUser);\n  });\n\nconst loadRepos = octokit.repos\n  .listForUser({\n    username\n  })\n  .then(() =&gt; {\n    setRepos(loadRepos);\n  });</code></pre><!--kg-card-end: code--><p>It looked syntactically correct, but now both calls are asynchronous without being controlled, which would easily obstruct the program flow in overall. You'll need a manager to consolidate both calls to return data first before proceed. Let us hire <code>Promise.all</code> to do that.</p><!--kg-card-begin: code--><pre><code class=\"language-es6\">const dataPromises = [\n  octokit.users.getByUsername({\n    username\n  }),\n  octokit.repos.listForUser({\n    username\n  })\n];\n\nPromise.all(dataPromises).then(allPromises =&gt; {\n  const [userCall, repoCall] = allPromises;\n  setUser(userCall.data);\n  setRepos(repoCall.data);\n  setLoading(false);\n});</code></pre><!--kg-card-end: code--><p><code>Promise.all</code> will make sure every async call is finished before resolving all promises into one single array consists of the resolved data of each async call following the order in <code>dataPromises</code> array.</p><h2 id=\"conclusion\">Conclusion</h2><p>There's a deep knowledge of asynchronous programming in JavaScript which is available to <a href=\"https://eloquentjavascript.net/11_async.html\">read online for free</a>, and this blog post merely scratching the surface by introducing the practical application of Promise in our projects using Node.js or any modern JavaScript tools including frontend frameworks and libraries. Based on my personal experience, it is important to make sure every Promise is being handled, as a program might remain running indefinitely if the async calls are not being handled properly, and this is especially hard to debug if you have many async calls scattered across files within a project.</p><p>By going through the improvements from a callback hell to using <code>Promise.all</code> to run two API calls asynchronously, hope this makes things clearer for you to understand how to utilize JavaScript Promise.</p><h2 id=\"external-read-and-resources\">External Read and Resources</h2><ol><li><a href=\"https://medium.freecodecamp.org/how-to-make-a-promise-out-of-a-callback-function-in-javascript-d8ec35d1f981\">https://medium.freecodecamp.org/how-to-make-a-promise-out-of-a-callback-function-in-javascript-d8ec35d1f981</a></li><li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then</a></li><li><a href=\"https://eloquentjavascript.net/11_async.html\">https://eloquentjavascript.net/11_async.html</a></li></ol>","url":"http://waiyanyoon.com/introduction-to-promise/","uuid":"c2c233a6-21f1-4b9e-b05d-18a110bba835","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5ce3c3de9f845f2425e992e2"}},{"node":{"id":"Ghost__Post__5b1a743fbd54885f920892ab","title":"Understanding Basics of React Context","slug":"understanding-basics-of-react-context","featured":false,"feature_image":null,"excerpt":"Use React Context to reduce delegation of properties across a component tree.","custom_excerpt":"Use React Context to reduce delegation of properties across a component tree.","created_at_pretty":"08 June, 2018","published_at_pretty":"08 June, 2018","updated_at_pretty":"08 June, 2018","created_at":"2018-06-08T20:19:11.000+08:00","published_at":"2018-06-08T21:40:25.000+08:00","updated_at":"2018-06-08T21:48:20.000+08:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Yoon Wai Yan","slug":"yoonwaiyan","bio":null,"profile_image":"http://waiyanyoon.com/content/images/2018/04/yoonwaiyan-1.jpeg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Yoon Wai Yan","slug":"yoonwaiyan","bio":null,"profile_image":"http://waiyanyoon.com/content/images/2018/04/yoonwaiyan-1.jpeg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"JavaScript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The use of React Context with renderProps that's introduced since React v16.3 is\nhighly being recommended in React community to pass global level variables to\nchild components, especially when the passing of the props from parent component\nto deep levels of child components, for example:\n\nThe code snippet before using React Context:\n\nimport React from 'react';\n// ...\n\nconst LoggedInUser = ({ user: { name } }) => (\n  <Fragment>\n    <span>Logged in as {name}</span>\n  </Fragment>\n);\n\nconst Navbar = ({ menu, user }) => (\n  <div>\n    <NavigationMenu menus={menu} />\n    <LoggedInUser user={user} />\n  </div>\n);\n\nclass Dashboard extends PureComponent {\n  render() {\n    const menu = [\n      { name: 'Home', url: '/' },\n      { name: 'Preferences', url: '/preferences' }\n    ];\n\n    // user is available at higher level of component\n    const { user, posts } = this.props;\n\n    return (\n      <Fragment>\n        <Navbar menu={menu} user={user} />\n        {posts.map(post => <BlogPost post={post} />)}\n      </Fragment>\n    );\n  }\n}\n\nclass App extends Component {\n  state = {\n    user: {}\n  };\n\n  componentDidMount() {\n    fetchUser().then(user => {\n      this.setState({ user });\n    });\n  }\n\n  render() {\n    const { user } = this.state;\n\n    return (\n      <div>\n        <Route url=\"/\" render={() => <Dashboard user={user} />} />\n      </div>\n    );\n  }\n}\n\n\n\nYou'll notice the use of user  is delegated from Dashboard  component down to \nLoggedInUser  without being used by the components along the delegation. It\nincreases complexity when the prop is delegated in a handful of levels down\nespecially when there are multiple props being passed down, which is the case of\nthe React codebase of my company project.\n\nNow we're going to replace the props delegation with React.Context. We first\ncreate an Auth React Context:\n\nimport React, { createContext } from 'react';\n\nconst AuthContext = createContext({ isLoggedIn: false, user: {} });\n\nexport default AuthContext;\n\n\ncreateContext()  will create two sub-components: Provider  and Consumer. \nConsumer  provides render props of an object that contains isLoggedIn  and user \nproperties. Now we 'll consume the user object in Navbar  and remove the props\nfrom Dashboard:\n\nimport React from 'react';\nimport AuthContext from './AuthContext';\n\n// ...\n\n// use AuthContext.Consumer to obtain user object\nconst Navbar = ({ menu, user }) => (\n  <div>\n    <NavigationMenu menus={menu} />\n    <AuthContext.Consumer>\n      {({ isAuth, user }) => <LoggedInUser user={user} />}\n    </AuthContext.Consumer>\n  </div>\n);\n\nclass Dashboard extends Component {\n  render() {\n    const menu = [\n      { name: 'Home', url: '/' },\n      { name: 'Preferences', url: '/preferences' }\n    ];\n\n    const { posts } = this.props;\n\n    // now we removed user from the list of props\n    return (\n      <Fragment>\n        <Navbar menu={menu} />\n        {posts.map(post => <BlogPost post={post} />)}\n      </Fragment>\n    );\n  }\n}\n\n// ...\n\n\nBy using AuthContext.Consumer, we're able to access the user  object directly\nwithout passing it from Dashboard  component, but when we try to log user to the\nconsole, it appears that user is an empty object. This is because the default\nvalue provided by AuthContext  is an empty user. Now we'll set the value of user\nusing AuthContext.Provider:\n\n// ...\n\nclass App extends Component {\n  state = {\n    user: {},\n    isLoggedIn: false\n  };\n\n  componentDidMount() {\n    fetchUser().then(user => {\n      this.setState({ user, isLoggedIn: true });\n    });\n  }\n\n  render() {\n    const { user } = this.state;\n\n    return (\n      <div>\n        <AuthContext.Provider value={{ user, isLoggedIn }}>\n          <Route url=\"/\" component={Dashboard} />\n        </AuthContext.Provider>\n      </div>\n    );\n  }\n}\n\n// ...\n\n\nNow we have the user information available in the Consumer!\n\n\n--------------------------------------------------------------------------------\n\nReact Context is especially useful for:\n\n 1. User authentication and routes management\n 2. Locale and translations management\n 3. Theme or display settings\n 4. Modal management\n 5. State management (instead of Redux)\n\nThe use of each example above is available in the external links provided below.\nCurrently React Context is only used for ActionCable web socket configuration in\nour project as we've just upgraded the React version to version 16.3.2. There is\na good chance of using it for other purposes within the project to clean up the\ndeep delegation of certain properties.\n\nExternal links:\n 1. https://medium.freecodecamp.org/how-to-protect-your-routes-with-react-context-717670c4713a\n 2. https://codeburst.io/what-can-react-context-api-do-for-you-multi-language-text-modals-and-theme-switchers-9cfbc8e5ee5e\n 3. https://reactjs.org/docs/context.html","html":"<p>The use of React Context with renderProps that's introduced since React v16.3 is highly being recommended in React community to pass global level variables to child components, especially when the passing of the props from parent component to deep levels of child components, for example:</p>\n<p>The code snippet before using React Context:</p>\n<pre><code class=\"language-javascript\">import React from 'react';\n// ...\n\nconst LoggedInUser = ({ user: { name } }) =&gt; (\n  &lt;Fragment&gt;\n    &lt;span&gt;Logged in as {name}&lt;/span&gt;\n  &lt;/Fragment&gt;\n);\n\nconst Navbar = ({ menu, user }) =&gt; (\n  &lt;div&gt;\n    &lt;NavigationMenu menus={menu} /&gt;\n    &lt;LoggedInUser user={user} /&gt;\n  &lt;/div&gt;\n);\n\nclass Dashboard extends PureComponent {\n  render() {\n    const menu = [\n      { name: 'Home', url: '/' },\n      { name: 'Preferences', url: '/preferences' }\n    ];\n\n    // user is available at higher level of component\n    const { user, posts } = this.props;\n\n    return (\n      &lt;Fragment&gt;\n        &lt;Navbar menu={menu} user={user} /&gt;\n        {posts.map(post =&gt; &lt;BlogPost post={post} /&gt;)}\n      &lt;/Fragment&gt;\n    );\n  }\n}\n\nclass App extends Component {\n  state = {\n    user: {}\n  };\n\n  componentDidMount() {\n    fetchUser().then(user =&gt; {\n      this.setState({ user });\n    });\n  }\n\n  render() {\n    const { user } = this.state;\n\n    return (\n      &lt;div&gt;\n        &lt;Route url=&quot;/&quot; render={() =&gt; &lt;Dashboard user={user} /&gt;} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\n</code></pre>\n<p>You'll notice the use of <code>user</code> is delegated from <code>Dashboard</code> component down to <code>LoggedInUser</code> without being used by the components along the delegation. It increases complexity when the prop is delegated in a handful of levels down especially when there are multiple props being passed down, which is the case of the React codebase of my company project.</p>\n<p>Now we're going to replace the props delegation with React.Context. We first create an Auth React Context:</p>\n<pre><code class=\"language-javascript\">import React, { createContext } from 'react';\n\nconst AuthContext = createContext({ isLoggedIn: false, user: {} });\n\nexport default AuthContext;\n</code></pre>\n<p><code>createContext()</code> will create two sub-components: <code>Provider</code> and <code>Consumer</code>. <code>Consumer</code> provides render props of an object that contains <code>isLoggedIn</code> and <code>user</code> properties. Now we 'll consume the user object in <code>Navbar</code> and remove the props from <code>Dashboard</code>:</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport AuthContext from './AuthContext';\n\n// ...\n\n// use AuthContext.Consumer to obtain user object\nconst Navbar = ({ menu, user }) =&gt; (\n  &lt;div&gt;\n    &lt;NavigationMenu menus={menu} /&gt;\n    &lt;AuthContext.Consumer&gt;\n      {({ isAuth, user }) =&gt; &lt;LoggedInUser user={user} /&gt;}\n    &lt;/AuthContext.Consumer&gt;\n  &lt;/div&gt;\n);\n\nclass Dashboard extends Component {\n  render() {\n    const menu = [\n      { name: 'Home', url: '/' },\n      { name: 'Preferences', url: '/preferences' }\n    ];\n\n    const { posts } = this.props;\n\n    // now we removed user from the list of props\n    return (\n      &lt;Fragment&gt;\n        &lt;Navbar menu={menu} /&gt;\n        {posts.map(post =&gt; &lt;BlogPost post={post} /&gt;)}\n      &lt;/Fragment&gt;\n    );\n  }\n}\n\n// ...\n</code></pre>\n<p>By using <code>AuthContext.Consumer</code>, we're able to access the <code>user</code> object directly without passing it from <code>Dashboard</code> component, but when we try to log user to the console, it appears that user is an empty object. This is because the default value provided by <code>AuthContext</code> is an empty user. Now we'll set the value of user using <code>AuthContext.Provider</code>:</p>\n<pre><code class=\"language-javascript\">// ...\n\nclass App extends Component {\n  state = {\n    user: {},\n    isLoggedIn: false\n  };\n\n  componentDidMount() {\n    fetchUser().then(user =&gt; {\n      this.setState({ user, isLoggedIn: true });\n    });\n  }\n\n  render() {\n    const { user } = this.state;\n\n    return (\n      &lt;div&gt;\n        &lt;AuthContext.Provider value={{ user, isLoggedIn }}&gt;\n          &lt;Route url=&quot;/&quot; component={Dashboard} /&gt;\n        &lt;/AuthContext.Provider&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\n// ...\n</code></pre>\n<p>Now we have the user information available in the Consumer!</p>\n<hr>\n<p>React Context is especially useful for:</p>\n<ol>\n<li>User authentication and routes management</li>\n<li>Locale and translations management</li>\n<li>Theme or display settings</li>\n<li>Modal management</li>\n<li>State management (instead of Redux)</li>\n</ol>\n<p>The use of each example above is available in the external links provided below. Currently React Context is only used for ActionCable web socket configuration in our project as we've just upgraded the React version to version 16.3.2. There is a good chance of using it for other purposes within the project to clean up the deep delegation of certain properties.</p>\n<h3 id=\"externallinks\">External links:</h3>\n<ol>\n<li><a href=\"https://medium.freecodecamp.org/how-to-protect-your-routes-with-react-context-717670c4713a\">https://medium.freecodecamp.org/how-to-protect-your-routes-with-react-context-717670c4713a</a></li>\n<li><a href=\"https://codeburst.io/what-can-react-context-api-do-for-you-multi-language-text-modals-and-theme-switchers-9cfbc8e5ee5e\">https://codeburst.io/what-can-react-context-api-do-for-you-multi-language-text-modals-and-theme-switchers-9cfbc8e5ee5e</a></li>\n<li><a href=\"https://reactjs.org/docs/context.html\">https://reactjs.org/docs/context.html</a></li>\n</ol>\n","url":"http://waiyanyoon.com/understanding-basics-of-react-context/","uuid":"a041e3fb-f428-402b-8537-37d36417b9b5","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5b1a743fbd54885f920892ab"}},{"node":{"id":"Ghost__Post__5ae1cd81bd54885f92089288","title":"Use of React.Fragment","slug":"react-fragment","featured":false,"feature_image":null,"excerpt":"Use React Fragment to wrap adjacent components instead of `div`.","custom_excerpt":"Use React Fragment to wrap adjacent components instead of `div`.","created_at_pretty":"26 April, 2018","published_at_pretty":"26 April, 2018","updated_at_pretty":"27 April, 2018","created_at":"2018-04-26T21:00:49.000+08:00","published_at":"2018-04-26T21:30:21.000+08:00","updated_at":"2018-04-27T09:37:37.000+08:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Yoon Wai Yan","slug":"yoonwaiyan","bio":null,"profile_image":"http://waiyanyoon.com/content/images/2018/04/yoonwaiyan-1.jpeg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Yoon Wai Yan","slug":"yoonwaiyan","bio":null,"profile_image":"http://waiyanyoon.com/content/images/2018/04/yoonwaiyan-1.jpeg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"JavaScript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"React developers know what does it mean when they saw this error:\n\nAdjacent JSX elements must be wrapped in an enclosing tag\n\nIt's simply fixed by adding <div>  tags between the element. At least it used to\nbe, until I saw React.Fragment  in a blog and read the new official\ndocumentation of React. It's as simple as replacing <div>  tag with \nReact.Fragment:\n\nimport React, { Fragment } from 'react';\n\nconst MyFragment = () => (\n    return (\n        <Fragment>\n            <div>First div</div>\n            <div>Second div</div>\n        </Fragment>\n    )\n);\n\nexport default MyFragment;\n\n\nThe use of <Fragment>  will not render extra <div>  tag, which is a good news in\ncertain case of styling.","html":"<p>React developers know what does it mean when they saw this error:</p>\n<blockquote>\n<p>Adjacent JSX elements must be wrapped in an enclosing tag</p>\n</blockquote>\n<p>It's simply fixed by adding <code>&lt;div&gt;</code> tags between the element. At least it used to be, until I saw <code>React.Fragment</code> in a blog and read the new official documentation of React. It's as simple as replacing <code>&lt;div&gt;</code> tag with <code>React.Fragment</code>:</p>\n<pre><code class=\"language-javacript\">import React, { Fragment } from 'react';\n\nconst MyFragment = () =&gt; (\n    return (\n        &lt;Fragment&gt;\n            &lt;div&gt;First div&lt;/div&gt;\n            &lt;div&gt;Second div&lt;/div&gt;\n        &lt;/Fragment&gt;\n    )\n);\n\nexport default MyFragment;\n</code></pre>\n<p>The use of <code>&lt;Fragment&gt;</code> will not render extra <code>&lt;div&gt;</code> tag, which is a good news in certain case of styling.</p>\n","url":"http://waiyanyoon.com/react-fragment/","uuid":"488e128f-b71f-4c93-af5f-a8cfd39277b5","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5ae1cd81bd54885f92089288"}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"react","limit":12,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}}